# 消息队列和事件循环

- 前提： 每个渲染进程都有一个主线程，主线程要处理DOM和计算样式
- 单线程 处理安排好的任务 串行执行任务 线程开始 --> 执行任务 --> 线程退出

- 线程运行过程中处理新任务(在线运行过程中，能接收执行新的任务，要采用事件循环机制)

# 线程中引入事件循环:

- 初始化线程 --> 等待输入任务 --> 事件循环 --> 执行任务

- 其他进程发送消息给渲染主线程

- 渲染主线程 --> 并行执行IO事件 --> IO线程发送资源加载完成事件 && 鼠标点击事件 && 其他事件

- 线程模型 -- 改进 --> 队列 + 循环

- 三步改造
 - 添加一个消息队列
 - IO线程中产生的新任务添加进消息队列尾部
 - 渲染主线程会循环地从消息队列头读取任务，执行任务

- 多个线程操作同一个消息队列， 需要在添加任务和取出任务的时候添加一个同步锁

- 消息队列实现线程之间的消息通信

- 渲染进程会专门有一个IO线程用来接收其他进程传过来的消息

# 消息队列中的任务类型

- 输入事件、微任务、文件读写、WebSocket、JS定时器

# 页面主线程安全退出

- 确定要退出当前页面时， 页面主线程设置一个退出标志变量， 每执行完一次任务，判断是否有设置退出标志

# 页面使用单线程的缺点

- 处理高优先级任务(观察者模式监听DOM变化)
    - DOM发生变化，若采用同步通知方式，会影响当前任务的执行效率， 异步方式通知，又会影响监控的实时性
    - 微任务 宏任务
- 单个任务执行时间过长

# 浏览器页面时如何运行的

- 执行Main项目， 记录主线程执行过程中的所有任务

- 每个任务下还有子任务， 其中Parse HTML任务负责把HTML解析为DOM，如果在执行解析HTML时遇到JS脚本，那就暂停HTML解析二去执行JS脚本

# summary 

- 确定任务，可使用单线程按顺序处理任务(第一版线程模型)

- 在线程执行过程接收并处理任务,需要引入循环语句和事件系统(第二版线程模型)

- 还要接收其他线程发送过来的任务，要引入消息队列 (第三版线程模型)

- 其他进程要发任务给页面主线程，需要通过IPC把任务发送给渲染进程的IO线程，IO线程在把任务发送给页面主线程

- 消息队列机制不灵活，为了适应效率和时效性，引入微任务

# QA 结合消息队列和事件循环，你认为微任务是什么？ 引入微任务可以带来什么优势